Linux权限管理之基本权限
		Linux权限管理之基本权限
		正常情况应该为：部门负责人为管理员，所有工程师为普通用户
		1.文件基本权限****
		-rw-r--r--	第一个-表示文件类型（-文件 d目录 l软链接文件）
		rw-（u所有者） r--（g所属组） r--（o其他人）
		r读 w写 x执行
		chmod命令 修改文件权限模式
		chmod [选项] 模式 文件名
		chmod u+x user.sh	给user用户添加执行权限，只有user才可以执行
		chmod g+w,o+w user.sh 给用户组以及其他用户添加写权限
		chmod u-x,g-w,o-w user.sh 将刚刚赋予的权限全部删掉
		chmod a=rwx user.sh chmod u=rwx,g=rw user.sh 用 = 可以直接赋予权限，用a直接给所有人赋予权限
		权限也可以用数字表示：r---4 w---2 x---1
		rwxr-xr-x 就可以用755表示
		chmod 755 user.sh
		再改为普通的文件权限-rw-r--r-- 就可以 chmod 644 user.sh
		常用权限：777最高权限 644常用文件权限 755执行权限

文件夹----》文件----》文件数据
		（1）数据是放在文件中的。
		（2）文件名是放在目录中的。
		（3）分区比较：
		【1】文件内容和文件是放在一块区域的空间下。
		【2】二文件名是放在文件夹的那块区域的空间下。
		【3】所以对文件有【写权限】，是不能够删除文件的【原因：】文件名是放在文件夹的那个空间下的， 你并没有给文件夹的删除权限，所以他的下级文件是没办法删除的

		权限对文件的作用
		rwx读写执行到底能干嘛呢？
		r：读取文件内容（cat/more/head/tail）
		w: 编辑、新增、修改文件内容（vi/vim/echo）(echo 内容 >>/> 文件名)
		虽然w是写权限，但是不包含删除文件。

		权限对目录的作用
		r:可以查 询目录下文件名（ls）
		w:具有修改目录结构的权限。如新建文件和目录，删除此目录下的文件和目录，重命名此目录下文件和目录，剪切（touch rm mv cp)
		x:可以进入目录（cd）
		对文件来讲;最高权限是 x
		对目录来讲：最高权限是 w
		对目录来讲，只有0 5 7 权限成立，只有进入目录1才可以有执行2，
		其他权限没有意义，而且目录的最高权限是w，权限是对下一层内容来说的

		修改文件所有者：chown 用户名 文件名
		修改文件所属组：chgrp 组名 文件名
		同时改变所有者和所属组：chown 用户名：用户名 文件名
		所有者：所属组
		分配权限核心原则：在最小权限下能够实现要求

		windows中的文件默认权限全部从上一级继承而来。
		linux中查看默认权限umask
		0022 第一位0特殊权限，默认权限为0022（此为root用户等）
		注：其他用户[UID>199]默认权限是0002，在/etc/profile下可以看见

		umask 0022 临时生效
		/etc/profile 永久生效

		文件默认没有执行权限，必须手工赋予。故而默认最大权限为666。
		666= -rw-rw-rw-
		022= -----w--w- 666-022=-rw-r--r--
		文件默认最大权限为777 umask默认为0000 默认权限为777


Linux权限管理之特殊权限（SetUID/SetGID/Sticky BIT）
		查看分区ACL权限是否开启：
		· dumpe2fs -h /dev/sda5
		dumpe2fs命令是查询指定分区详细文件系统信息的命令；
		选项：
		-h：仅显示超级块中信息，而不显示磁盘块组的详细信息；

		临时开启分区ACL权限
		· mount -o remount,acl /
		·重新挂载根分区，并挂在加入ACL权限；

		永久开启分区ACL权限：
		·vi /etc/fstab
		··在默认文件系统后加上acl即可
		----例如UUID=24f28fc6-717e-4bcd-a5f7-32b959024e26 / ext4 defaults,acl 0 1

		·mount -o remount /
		----重新挂载文件系统或重启动系统，使修改生效；
		
	getfacl 文件名 //查看acl权限；
		setfacl 选项 文件名 //设定ACL权限的命令；
		选项：
		-m：设定ACL权限；
		-x：删除指定的ACL权限；
		-b：删除所有的ACL权限；
		-d：设定默认ACL权限；
		-k：删除默认ACL权限；
		-R：递归设定ACL权限；
	为用户设定ACL权限
		setfacl -m u:用户名:权限(rwx) 文件名
	为用户组设定ACL权限
		setfacl -m g:组名:权限(rwx) 文件名
		
		最大有效权限mask（使用命令getfacl 文件名显示的结果中倒数第二排会出现mask这个词）
		mask是用来指定最大有效权限的。如果我给用户赋予了acl权限，是需要和mask的权限“相与”
		才能得到用户的真正权限。相与是计算机中的术语，皆真方为真，有假便为假。
		（例：某文件所有者为tony，chmod赋予的普通权限为7，而acl赋予tony的权限为5，则acl权限会高于chmod权限）
		1.修改mask值的命令 setfacl -m m:rx 文件
		2.删除acl权限的命令
		setfacl -x u:用户名 文件 （删除指定用户的acl权限）
		setfacl -x g:组名 文件 （删除指定组的acl权限）
		setfacl -b 文件 （删除所有的acl权限）
		
		递归权限：在赋予目录权限的同时将权限赋予此文件夹下面的子文件权限
		setfacl -m u：用户名：权限 -R 目录名
		
		默认acl权限：把这个目录下以后所创建的所有文件都赋予某些权限。<br>
		setfacl -m d（default的缩写）：u：user1 目录名<br>
		
	超级用户提供sudo权限给下面的普通用户
		命令：
		a)在root用户下，visudo，拉到最底行，写上
		canglaos ALL=(ALL) /sbin/shutdown -r now，赋予普通用户重启命令，写的越详细越好，保存退出。
		b)然后在普通用户模式下面，sudo -l ,输入密码，然后sudo /sbin/shutdown -r now，执行命令。
	授权普通用户添加用户	
		user1 ALL=/usr/sbin/useradd #赋予user1添加用户的权限
		user1 ALL=/usr/bin/passwd #赋予user1更改密码的权限
		user1 ALL=/bin/vi #赋予user1使用vi更改任意文件的权限(包括/etc/shadow阔怕！)
		（会造成严重后果， 在运行该权限时，是root身份，甚至能更改root密码）
		加强版
		user1 ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd "", !/usr/bin/passwd root
		可以更改任意字母的用户密码， 用户名不能为空（如果空，则代表更改当前用户密码，而此时身份为root），
		用户名不能为root
		
		sudo(选项)(参数) 选项 
		-b：在后台执行指令； 
		-h：显示帮助； 
		-H：将HOME环境变量设为新身份的HOME环境变量； 
		-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。 
		-l：列出目前用户可执行与无法执行的指令； 
		-p：改变询问密码的提示符号； 
		-s：执行指定的shell； 
		-u<用户>：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份； 
		-v：延长密码有效期限5分钟； 
		-V ：显示版本信息。

（1）设定SetUID方法
  	4代表SUID
   	chmod 4755 文件名
   	chmod u+s 文件名
（2）SetUID功能
		1.只有可执行二进制程序才能设定SUID权限
		2.命令执行者要对该程序拥有x(执行)权限（如果当前文件没有执行权限，着会出现大S权限，大S权限是无效的，s=S+x，s才是超级权限。）
		3.命令执行者在执行该程序时获得该程序文件属主身份
		4.SetUID权限只在程序执行过程中有效

		passwd拥有SetUID权限，所以普通用户可以修改自己密码
		cat命令没有SetUID权限，所以普通用户不能查看/etc/shadow文件内容
		
	设定SetUID的方法<br>
		chmod 4755 abc， 这个4即表示SUID
		chmod u+s 文件名

		u+s =SUID(所有者）
		g+s=SGID（所属组）
		o+s=SBIT（其他人）

		取消方法
		chmod 0755 文件名
		chmod u-s 文件名

	定期检查suid的程序如下
		#!/bin/bash
		#搜索拥有SUID和SGID的文件 并保存
		find / -perm -4000 -o -perm -2000> /tmp/setuid.check
		#做循环 每次取出一个文件
		for i in $(cat /tmp/setuid.check）
		do
		#比对这个文件是否在模板文件中
		grep $i /home/suid.log> /dev/null
		#检测上一个命令的返回值，不为0 则错误
		if [ "$?" != "0" ]
		then
		echo "$i isn't in listfile!">>/home/suid_log_$(date +%F)
		fi
		done
		rm -rf /tmp/setuid.check
		
	1.SetGID针对文件的作用
		只有可执行二进制程序才能设定SGID权限
		命令执行者要对该程序拥有x(执行)权限
		命令执行执行程序时，组身份升级为该程序文件的属组
		SetGID权限只在程序执行过程中有效

		例子 、usr/bin/locate具有SetGID身份

		2.SetGID针对目录的作用
		普通用户必须对此目录必须拥有r和x权限，才能进入此目录
		普通用户在此目录中的有效组会变成此目录的属组
		若普通用户对此目录拥有w权限,新建的文件的默认属组是这个目录的属组

		3.设定SetGID
		chmod g+s 文件名
		chmod 2755 文件名

		4.取消SetGID
		chmod g-s 文件名
		chmod 0755 文件名	
		
	SBIT粘着位表示 t
		1.SBIT粘着位作用
		①粘着位目前只针对目录有效
		②普通用户对该用户拥有w和x权限，即写入权限
		③如果没有粘着位，因为普通用户拥有w权限，所有可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户即使拥有了w权限，也只能删除自己建立的文件，不能删除其他用户创建的文件。

		白话版： av目录的权限为777，user1进去建立了一个cangls,user2进去建立了bols，由于user2拥有w权限，所以他可以删除user1辛苦找到的cangls，为了防止悲剧发生，赋予粘着位，user2只能删除自己建立的文件，不能删除其他用户建立的文件。

		2.设置粘着位
		chmod 1755 目录名
		chmod o+s 目录名
		3.取消粘着位
		chmod 0755 目录名
		chmod o-s 目录名	
		
	为了完善SBIT权限的缺陷
		1.不可改变位权限:chattr
		命令格式  charrt[+-=][选项] 文件名/目录名
		+:增加权限
		-：删除权限
		=:等于某权限
		[选项]：
		i:将此文件锁定
		如果对文件设置i属性,那么不允许对文件进行删除，改名也不能添加和修改数据；
		如果对目录设置i属性，那么只能修改目录下文件的数据，但不能建立和删除文件。

		a:冻结此文件
		如果对文件设置a属性，那么只能在文件中增加数据，但不能删除也不能修改数据；
		如果对目录设置a属性，那么只允许在目录中建立和修改文件，但不允许删除。
		（添加内容只能用 echo >>输出重定向到文件中；vi不行，因为不能判断是修改还是增删内容）

		2.查看文件系统属性：lsattr 选项 文件名
		选项
		-a 显示所有文件和目录
		-d 仅列出目录本身的属性，而不是子文件的	